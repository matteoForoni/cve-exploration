#####################
# Import Libraries
#####################

import numpy as np
import os
import pandas as pd
import matplotlib.pyplot as plt
import streamlit as st
import seaborn as sb
import re
import utils.column_descriptions as cd
from datetime import datetime
from sklearn.cluster import KMeans

#####################
# Global Variables
#####################
cve_dataframe_text= 'CVE dataframe'
products_dataframe_text = 'Products dataframe'
vendors_dataframe_text = 'Vendors dataframe'
vendors_products_dataframe_text = 'Vendors Products dataframe'

#####################
# Functions
#####################

# Function to visualize text to web page
def write_text(text):
    st.text(text)

# Function to visualize simple text to web page
def generic_write(text):
    st.write(text)

# Function to visualize dataframe to web page
def write_df(df):
    st.dataframe(df)

# Function to create a subheader to web page
def write_subheader(text):
    st.subheader(text)

# Function to create a title to web page
def write_title(text):
    st.title(text)

# Function to create a title to web page
def write_header(text):
    st.header(text)

# Function to write markdown code to web page
def write_md(text):
    st.markdown(text)

# Function to write caption to web page
def write_caption(text):
    st.caption(text)

# Function to plot a bar chart
def bar_plot(figsize, x,y, data_range, xlabel, ylabel, title, y_ticks=[], color='#dc804b', width=0.6, xrotation=False, x_newlabels=[], y_labels=False):
    fig1 = plt.figure(figsize=figsize)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.bar(x[:data_range], y[:data_range], color=color, width=width)
    plt.title(title)

    # Enable x ticks rotation
    if xrotation:
        plt.xticks(rotation=45)
    
    # Changing x labels
    if len(x_newlabels) != 0:
        print(x_newlabels)
        plt.xticks(x[:data_range], labels=x_newlabels)

    # Changing y labels
    if len(y_ticks) != 0:
        plt.yticks(y_ticks)

    # Adding values into bars
    if y_labels: 
        for i in range(len(x[:data_range])):
            plt.text(i, y[i]//2, y[i], ha = 'center', 
                bbox = dict(facecolor = 'white', alpha = .5))

    return fig1

# Function to change products names for plotting
def rename_products(list_of_products):
    products_label = []
    for product in list_of_products:
        #print(products)
        product = re.sub('_linux$', '', product)
        product = product.replace('_', '\n')
        product = product.title()
        products_label.append(product)
    return products_label

# Function to change vendors names for plotting
def rename_vendors(list_of_vendors):
    vendors_label = []
    for vendor in list_of_vendors:
        vendor = vendor.replace('-', '\n')
        vendor = vendor.title()
        vendors_label.append(vendor)
    return vendors_label

# Function to plot a pie chart
def pie_chart(figsize, title, values, labels, legend_loc='lower right'):
    fig = plt.figure(figsize=figsize)
    plt.title(title)
    plt.pie(values, labels=labels, autopct='%.2f%%')
    plt.legend(loc=legend_loc)
    return fig

# Function to plot a line plot
def plot(figsize, x, y, xlabel, ylabel, title, xticks=[]):
    fig = plt.figure(figsize=figsize)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.plot(x, y)
    plt.title(title)

    if len(xticks) != 0:
        plt.xticks(xticks)
    
    return fig

# Function to apply kmeans
def kmeans_model_predict(x, n_cluster, init='random', n_init=10, max_iter=100, tol=1e-04, random_state=0):
    km = KMeans(n_clusters=n_cluster, init=init, n_init=n_init, max_iter=max_iter, tol=tol, random_state=random_state)
    return km.fit_predict(x), km.inertia_

# Function to plot seaborn scatter plot
def scatter_plot(figsize, df, xcol, ycol, huecol, sizecol, title, xlabel, ylabel):
    fig = plt.figure(figsize=figsize)
    sb.scatterplot(data=df, x=xcol, y=ycol, hue=huecol, size=sizecol, palette=['#e6ac00','green','red', '#800000'])
    plt.title(title)
    plt.xlabel(xlabel)
    plt.ylabel(ylabel)
    plt.legend()
    return fig

#####################
# Main
#####################

full_path = os.path.realpath(__file__)
project_folder = os.path.dirname(full_path)

## Reading datasets
cve_df = pd.read_csv(f'{project_folder}\\data\\cve.csv')
products_df = pd.read_csv(f'{project_folder}\\data\\products.csv')
vendors_df = pd.read_csv(f'{project_folder}\\data\\vendors.csv')
vendors_products_df = pd.read_csv(f'{project_folder}\\data\\vendor_product.csv')
servers_df = pd.read_csv(f'{project_folder}\\data\\servers.csv')

# Initializing web page
write_title("CVE Exploration")
generic_write('The project wants to analyze a dataset containing a list of vulnerabilities affecting IT tools')
generic_write('All IT bugs are saved in a list mainteined by Mitre, a cybersecurity organization, called CVE')
generic_write('The main goal of the project is to classify a list of servers using CVE database and other parameters')
generic_write('The classification result can be very useful for IT managers in order to plan the remediation')
write_md('**Source dataset**:')
write_text('https://www.kaggle.com/datasets/andrewkronser/cve-common-vulnerabilities-and-exposures?select=cve.csv')
write_md('For more information read ```README.md``` file')

st.sidebar.write('Settings')
write_md('> Use the **sidebar menu** to show advanced features')
#####################
## Data Exploration
#####################

write_header('Data Exploration')

#####################
# CVE dataframe exploration
write_subheader(cve_dataframe_text)
generic_write('Dataframe cointaining all CVEs')
write_df(cve_df)
# print(cve_df.info())
# print(cve_df.describe().T)

# Add expander to hide column information if not necessary
with st.expander('Show column description'):
    for col in cve_df.columns:
        write_md(f"- ```{col.upper()}```: {cd.get_column_description('cve',col)}") # Using the external file to get column description

# Add expander for columns cointaning null values
with st.expander('Show advanced information'):
    for col in ['access_authentication', 'access_complexity', 'access_vector', 'impact_availability', 'impact_confidentiality', 'impact_integrity']:
        write_md(f"**{col.upper()}** column unique values: ```{cve_df[col].unique()}```")

#####################    
# Products dataframe exploration
write_subheader(products_dataframe_text)
generic_write('Dataframe cointaining all CVEs associated to a product')
write_df(products_df)
# print(products_df.info())
# print(products_df.describe().T)

#####################
# Vendors dataframe exploration
write_subheader(vendors_dataframe_text)
generic_write('Dataframe cointaining all CVEs associated to a vendor')
write_df(vendors_df)
# print(vendors_df.info())
# print(vendors_df.describe().T)

#####################
# Vendors dataframe exploration
write_subheader(vendors_products_dataframe_text)
generic_write('Dataframe cointaining the combination between vendors and products')
write_df(vendors_products_df)
# print(vendors_products_df.info())
# print(vendors_products_df.describe().T)

#####################
## Data Cleaning
#####################

#####################
# CVE dataset cleaning

# Filling all NaN values with NONE
for col in ['access_authentication', 'access_complexity', 'access_vector', 'impact_availability', 'impact_confidentiality', 'impact_integrity']:
    cve_df[col].fillna('NONE', inplace=True)

# Remaning the first column
cve_df.rename(columns={'Unnamed: 0': 'cve_id'}, inplace=True)

#####################
# Products dataset cleaning

# Drop all NaN values
products_df.dropna(inplace=True)

#####################
# Vendors dataset cleaning

# Rename the first column
vendors_df.rename(columns={'Unnamed: 0': 'cve_id'}, inplace=True)

# Drop all NaN values
vendors_df.dropna(inplace=True)

#####################
# Vendors products dataset cleaning

# Rename the first column
vendors_products_df.rename(columns={'Unnamed: 0': 'id'}, inplace=True)

# Visualizing cleaned data
if st.sidebar.checkbox('Display final datasets'):
    write_header('Final datasets')
    generic_write('Final datasets to use in the project after the application of data cleaning')

    # Visualize CVE dataset
    write_subheader(cve_dataframe_text)
    write_df(cve_df)
    with st.expander('Show activities done'):
        write_md("- Rename the first column to ```CVE_ID```")
        write_md("- Fill all NaN values as ```None```")

    write_subheader(products_dataframe_text)
    write_df(products_df)
    with st.expander('Show activities done'):
        write_md("- Drop all NaN values (42)")

    write_subheader(vendors_dataframe_text)
    write_df(vendors_df)
    with st.expander('Show activities done'):
        write_md("- Rename the first column to ```CVE_ID```")
        write_md("- Drop all NaN values (42)")

    write_subheader(vendors_products_dataframe_text)
    write_df(vendors_products_df)
    with st.expander('Show activities done'):
        write_md("- Rename the first column to ```ID```")

#####################
# Find out info inside the datasets
#####################
write_header('Find information')

# Merging products dataset with cve dataset
products_cve_df = pd.merge(products_df, cve_df, on='cve_id')

# Renaming column vulnerable_product to merge with vendor dataset
products_cve_df.rename(columns={'vulnerable_product': 'product'}, inplace=True)

# Merging products with cves dataset with vendors dataset
products_completed_df = pd.merge(vendors_products_df, products_cve_df, on='product')

# Drop id columns
products_completed_df.drop(columns=['id'], inplace=True)

write_subheader('Find Vulnerabilities')
generic_write('Search vulnerabilities information inside the dataset using the CVE ID')

# Using text input in the web page
vuln_code = st.text_input('CVE ID', placeholder="CVE-2019")

# Creating regexp from text written by the user
vuln_regexp = f'.*{vuln_code}.*'

# Printing cve filtered using regular expression
generic_write(cve_df[cve_df['cve_id'].str.match(vuln_regexp)])

if (vuln_code): 
    # Search vulnerable products if text field is populated
    affected_products = products_completed_df.loc[products_completed_df['cve_id'].str.match(vuln_regexp), 'product'].unique()

    # Choosing only the first 50 products to manage web page space
    if len(affected_products) <= 50:
        write_md('**Affected products**: ')
        write_md(f'```{", ".join(affected_products)}```') 
    else: 
        write_md("**ATTENTION**: showing only first 50 affected products")
        write_md('**Affected products**: ')
        write_md(f'```{", ".join(affected_products[:50])}```') 

if st.sidebar.checkbox('Enable products or vendors research'):
    write_subheader('Find Vulnerable Products or Vendors')
    generic_write('Search vulnerabilities for a specific product or vendor')

    col1, col2 = st.columns([1, 3])
    with col1:
        # Define the search parameter
        search_parameter = st.selectbox('Search parameter', ['vendor', 'products'])
    with col2:
        # Define the search string
        search_string = st.text_input('Search string', placeholder="google")
        search_regexp = f'.*{search_string}.*'

    if search_string and search_parameter:
        if search_parameter == 'vendor':
            generic_write(products_completed_df[products_completed_df['vendor'].str.match(search_regexp)])
        else:
            generic_write(products_completed_df[products_completed_df['product'].str.match(search_regexp)])

#####################
# Data Visualization
#####################

write_header('Plots')

#####################
# Correlation between cvss and cwe_code of cve dataset
if st.sidebar.checkbox('Display CVE datasets correlation'):
    write_subheader("CVE Dataset Correlation Matrix")
    fig1 = plt.figure(figsize=(2,1))
    sb.heatmap(cve_df.corr())
    generic_write(fig1)
    write_md("There isn't any correlation between ```CVSS``` and ```CWE_CODE``` columns")

#####################
# Plotting Number of Products per Vendors
write_subheader("Products per Vendor")
generic_write("Plotting the number of products for each vendor in the dataset")

# Grouping the data
count_products_series = vendors_products_df.groupby('vendor').count()['product']

# Slider to select the number of vendor to plot
data_range = st.slider('How many vendor do you want to plot?', 2, 20, 5, 1)

# Sorting series in decreasing order
count_products_series = count_products_series.sort_values(ascending=False)

# Create bar plot
vendors_rename = rename_vendors(count_products_series.index[:data_range].to_list())
fig1 = bar_plot((22,10), count_products_series.index, count_products_series, data_range, 'Vendors', 'Number of Products', 'Products per Vendor', np.arange(0,3000, step=800), x_newlabels=vendors_rename)
generic_write(fig1)

#####################
# Plotting Number of Vulnerabilities for products

write_subheader("Vulnerabilities per Products")
generic_write("Plotting the number of vulnerabilities for each product")

# Grouping and sorting the data
count_vuln_series = products_df.groupby('vulnerable_product').count()['cve_id']
count_vuln_series = count_vuln_series.sort_values(ascending=False)

# Slider to select the number of products to plot
products_data_range = st.slider('How many products do you want to plot?', 2, 20, 5, 1)

# Create bar plot
# to_list() function necessary to convert pandas Index object to a list of values
products_renamed = rename_products(count_vuln_series.index[:products_data_range].to_list())

fig1 = bar_plot((22,10), count_vuln_series.index, count_vuln_series, products_data_range, 'Products', 'Number of Vulnerabilities', 'Vulnerabilities per Products', color='#85e085', x_newlabels=products_renamed, y_labels=True)
generic_write(fig1)

#####################
# Plotting Number of Vulnerabilities per Vendors

write_subheader("Vulnerabilities per Vendors")
generic_write("Plotting the number of vulnerabilities for each vendors")

# Grouping and sorting the data
count_vuln_series = vendors_df.groupby('vendor').count()['cve_id']
count_vuln_series = count_vuln_series.sort_values(ascending=False)

# Slider to select the number of products to plot
vendors_data_range = st.slider('How many vendors do you want to plot?', 2, 20, 5, 1)

# Create bar plot
# to_list() function necessary to convert pandas Index object to a list of values
vendors_rename = rename_vendors(count_vuln_series.index[:vendors_data_range].to_list())
fig1 = bar_plot((22,10), count_vuln_series.index, count_vuln_series, vendors_data_range, 'Vendors', 'Number of Vulnerabilities', 'Vulnerabilities per Vendors', color='#4d94ff', x_newlabels=vendors_rename, y_labels=True)
generic_write(fig1)

#####################
# Plotting the classification of CVEs

write_subheader("Vulnerabilities classification by CVSS 2.0 and 3.0")
generic_write("Plotting the CVE classification, applying CVSS 2.0 and 3.0 ratings systems")


# Classify CVE dataset with CVSS 2.0 and 3.0 ratings systems
cvss_2_low_mask = (cve_df['cvss'] >= 0.0) & (cve_df['cvss'] < 4.0)
cvss_2_medium_mask = (cve_df['cvss'] >= 4.0) & (cve_df['cvss'] < 7.0)
cvss_2_high_mask = cve_df['cvss'] >= 7.0

cvss_3_none_mask = (cve_df['cvss'] >= 0.0) & (cve_df['cvss'] < 0.1)
cvss_3_low_mask = (cve_df['cvss'] >= 0.1) & (cve_df['cvss'] < 4.0)
cvss_3_medium_mask = (cve_df['cvss'] >= 4.0) & (cve_df['cvss'] < 7.0)
cvss_3_high_mask = (cve_df['cvss'] >= 7.0) & (cve_df['cvss'] < 9.0)
cvss_3_critical_mask = cve_df['cvss'] >= 9.0

# Add new columns with right values
cve_df.loc[cvss_2_low_mask, 'cvss-2'] = 'low'
cve_df.loc[cvss_2_medium_mask, 'cvss-2'] = 'medium'
cve_df.loc[cvss_2_high_mask, 'cvss-2'] = 'high'
cve_df.loc[cvss_3_none_mask, 'cvss-3'] = 'none'
cve_df.loc[cvss_3_low_mask, 'cvss-3'] = 'low'
cve_df.loc[cvss_3_medium_mask, 'cvss-3'] = 'medium'
cve_df.loc[cvss_3_high_mask, 'cvss-3'] = 'high'
cve_df.loc[cvss_3_critical_mask, 'cvss-3'] = 'critical'

col1, col2 = st.columns(2)
labels = []

with col1:
    # Count CVSS 2.0 classes
    count_vuln_series = cve_df.groupby('cvss-2').count()['cve_id']

    # Creating labels with values
    for i in count_vuln_series.index.to_list():
        labels.append(f'{i.capitalize()}: {count_vuln_series[i]}')

    fig1 = pie_chart((8,6), 'Vulnerabilities classification with CVSS 2.0', count_vuln_series, labels)
    generic_write(fig1)
with col2:
    # Count CVSS 3.0 classes
    count_vuln_series = cve_df.groupby('cvss-3').count()['cve_id']

    # Creating labels with values
    labels = []
    for i in count_vuln_series.index.to_list():
        labels.append(f'{i.capitalize()}: {count_vuln_series[i]}')

    fig1 = pie_chart((8,7), 'Vulnerabilities classification with CVSS 3.0', count_vuln_series, labels)
    generic_write(fig1)

# Append CVSS v2.0 and v3.0 ratings parameters
write_md('> CVSS v2.0 Ratings: Low 0.0-3.9, Medium 4.0-6.9, High 7.0-10.0')
write_md('> CVSS v3.0 Ratings: None 0.0, Low 0.1-3.9, Medium 4.0-6.9, High 7.0-8.9, Critical  9.0-10.0')

#####################
# Plotting vulnerabilities per year

write_subheader("Vulnerabilities per Year")
generic_write("Plotting the number of vulnerabilities for each year")

# Adding column pub_year for each row and convert pub_year as int
cve_df['pub_year'] = pd.DatetimeIndex(cve_df['pub_date']).year.astype(int)

count_vuln_series = cve_df.groupby('pub_year').count()['cve_id']

fig1 = plot((12,6), count_vuln_series.index, count_vuln_series, 'Years', 'Number of Vulnerabilities', 'Vulnerabilities x Year', count_vuln_series.index[::1])
generic_write(fig1)


#####################
# Machine Learning
#####################

write_header('Machine Learning application')
write_md('The main goal is to classify a set of servers by some parameters')
write_md('The parameters used to classify are: ```[is_dmz,days_since_patching, vulnerability_count, is_eol]```')
write_md('The algorithm used to classify the data is ```KMeans```')
write_subheader('Servers dataset')
write_md('Sample servers dataset, generated with a python script ```server_generation.py``` and enriched with vulnerability counts for each server')

# Count vulnerabilities for each products
count_vuln_series = products_df.groupby('vulnerable_product').count()['cve_id']
count_vuln_series = count_vuln_series.sort_values(ascending=False)

for index, row in servers_df.iterrows():
    servers_df.loc[index,'vulnerability_count'] = count_vuln_series[row['product']]

# Mapping vulnerability_count column as int
servers_df['vulnerability_count'] = servers_df['vulnerability_count'].astype(int)

generic_write(servers_df)
with st.expander('Show advanced information'):
    for col in servers_df.columns:
        write_md(f"- ```{col.upper()}```: {cd.get_column_description('server',col)}") # Using the external file to get column description

#####################
# Elbow method
write_subheader('Elbow Method')
# Parameters of classification
x = servers_df[['is_dmz','days_since_patching', 'vulnerability_count', 'is_eol']]

# Determining the best number of clusters
square_distances = []
nclusters_list = range(1,11)
for i in nclusters_list:
    y_pred, inertia = kmeans_model_predict(x, i, random_state=22)
    square_distances.append(inertia)

# Plotting elbow method results
fig1 = plot((4,3), nclusters_list, square_distances, 'Number of cluster', 'Inertia of Kmeans', 'Elbow Method', nclusters_list[::1])
generic_write(fig1)

write_md("The last significative change is obtained with number of clusters equals ```4```")

#####################
# Clustering
write_subheader('Server classification')
write_md("Number of clusters applied is ```4```")
write_md('The final classes are the following: ```[low vulnerable, medium vulnerable, critical vulnerable, high vulnerable]```')

# Predict classes
classes_label = ['low vulnerable', 'medium vulnerable', 'critical vulnerable', 'high vulnerable']
classes, inertia = kmeans_model_predict(x,4,random_state=22)
servers_df['label'] = classes

# Substitute label with labels names
for i in range(0,4):
    servers_df.loc[servers_df['label'] == i, 'label'] = classes_label[i]

write_md(f'The error of the clustering process is ```{inertia}```')

col1,col2 = st.columns(2)
with col1:
    fig1 = scatter_plot((12,6), servers_df, 'days_since_patching', 'vulnerability_count', 'label', 'is_eol', 'Compare vulns count and days since patching with is_eol', 'Days since patching', 'Vulnerability Count')
    generic_write(fig1)

with col2:
    fig1 = scatter_plot((12,6), servers_df, 'days_since_patching', 'vulnerability_count', 'label', 'is_dmz', 'Compare vulns count and days since patching with is_dmz', 'Days since patching', 'Vulnerability Count')
    generic_write(fig1)

